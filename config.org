#+TITLE: Config
#+property: header-args:emacs-lisp :tangle "./config.el"

* About this config
I needs to write more "literal" part. And This config need to have the huge refactoring. From <2022-10-19 水>, I wanna cleanup all the unnecessary thing in this month. Look what happen...

* Bookmarks
The search for project which is likely to be as most frequently edited place for developer. But other things you are likely to visit secondly should also be accessed easily. For that case, I've just added key-binding for that.
#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("b". "buffer")
       :desc "List bookmarks" "L" #'list-bookmarks
       :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save))
#+END_SRC

* utils
For the extended syntax or frequent generic things are gathered here.
Althought I place these here now, I'll put these in other file in this repository when the amount become huge.
#+begin_src emacs-lisp :results output
;switch statement like in the javascript.
;or this name can be match using the name of the python.
(cl-defmacro switch (piv (test &body expr) &rest rest)
  (when (equal (length rest) 0)
    'nil)
  `(if (equal ,piv ,test)
       ,@expr
     (switch ,piv
             ,@rest)))

(defmacro with-splited-window (body)
  `(progn
     (+evil-window-vsplit-a)
     (+evil/window-move-right)
     ,body))

(add-to-list 'load-path "/home/ryu/.emacs.d/.local/straight/repos/dash.el")
#+end_src

#+RESULTS:

* key-bindings
Just making key-bindings for category
** org
#+BEGIN_SRC emacs-lisp
;;not classified

(map! (:leader
  (:desc "gosh with splited window" "s h"
   ;;this is for shell but that's gauche, not eshell.
   (lambda () (interactive) (with-splited-window (run-scheme "")))
   :desc "zoom" "z z" #'+hydra/text-zoom/body
   :desc "org-table" "t o" #'org-table-create
   :desc "elgantt ""g n" #'elgantt-open
   :desc "find-file" "f f" #'find-file)))

;;org slide
(map! (:leader
      (:desc "tangle" "o t" #'org-babel-tangle
       :desc "org-slide-start" "o s s" #'org-tree-slide-mode
       :desc "org-slide-right" "o s l" #'org-tree-slide-move-next-tree)))

#+END_SRC

** screen
#+begin_src emacs-lisp
;;layout
(map! (:leader
       (:desc "右下がアジェンダ、左下がシェルです。" "l 1" #'split-screen-1
        :desc "clisp用のです" "l c l" #'split-screen-3
        :desc "contest用（ABCの）" "l c o" #'split-screen-4)))

;;ace-window
(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
(map! :leader
      :desc "ace-window" "a c" #'ace-window)
;;smart toggle
(map! :leader
      :desc "imenu-list"
      "l e" #'imenu-list-smart-toggle)
(map! :leader
      :desc "suspend emacs"
      "e x" #'suspend-emacs)

;;visual line of numbers ではない
#+end_src

#+RESULTS:
: imenu-list-smart-toggle

** snippet
#+begin_src emacs-lisp
(map! (:leader
      (:desc "snippets-find" "s n o" #'+snippets/find
      :desc "snippets-insert" "s n i" #'+snippets/new
      :desc "snippets-edit" "s n e" #'+snippets/edit)))
#+end_src

** text-edit
The "kill-ring" is clipboard with circler data-structure. This is really useful.
The key-binding is standing for "line-up" and "line-down". Sounds fair!!
#+begin_src emacs-lisp
(map! :leader
      :desc "heml kill ring"
      "k r" #'helm-show-kill-ring)

;;switching text up and down.
(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

(map! (:leader
      (:desc "line-swap-down" "l d"#'move-line-down
       :desc "line-swap-down" "l u"#'move-line-up)))
#+end_src

** Manual
#+begin_src emacs-lisp
(map! :leader
      :desc "man page"
      "d c"#'man)
#+end_src

** lisp
Key-binding for lisp would be pretty much the operation for the parenthesis. This is also useful especially for other language which use parenthesis a lot.
#+begin_src emacs-lisp
(map! :leader :desc "run sly" "a a" #'sly)

(map! (:leader
       (:desc "sexp-forward" "s x f" #'sp-forward-sexp
        :desc "sexp-backward" "s x b" #'sp-backward-sexp
        :desc "sexp-kill" "s x d" #'sp-kill-sexp
        :desc "sexp-copy" "s x y" #'sp-copy-sexp
        :desc "sexp-kill" "s x s" #'+default/search-other-project)))
#+end_src

#+RESULTS:
: +default/search-other-project

** godot
Currently, this is just for gdscript.el. When ~godoel~ is done, I'll put some key-bindings for that.
#+begin_src emacs-lisp
(map! :leader
      :desc  "hydra gd"
      "g d"#'gdscript-hydra-show)

#+end_src

** latex
#+begin_src emacs-lisp
(map! :leader
      :desc "latex-preview"
      "l p"#'org-latex-preview)
#+end_src
** w3m
This is for browser in emacs ~w3m~.
#+begin_src emacs-lisp
(map! (:leader
       (:desc "down on google"
        "o g" #'(lambda ()
                  (interactive)
                  (let ((search-word (read-string "google:: ")))
                    (if (equal (buffer-name (current-buffer)) "*w3m*")

                      (w3m-search "google" search-word)
                      (with-splited-window
                         (w3m-search "google" search-word))))))
       (:desc "open the link in the org file
but I don't really wanna do this cause this just prove that I can't over write the <return> key."
        "o o" #'(lambda ()
                  (interactive)
                  (let ((link (thing-at-point 'line t)))
                    (if (null (string-match "\\[\\[\\(.*\\)\\]\\[" link))
                        nil
                      (with-splited-window (w3m-goto-url (match-string 1 link))))
                    ))
        "o G" #'(lambda ()
                  (interactive)
                  (w3m-search-new-session "google" (read-string "google:: ")))
        "3 l" #'w3m-tab-next-buffer
        "3 h" #'w3m-tab-previous-buffer
        "3 d" #'w3m-delete-buffer)))

(map! (:leader
       (:desc "sexp-forward" "s x f" #'sp-forward-sexp
        :desc "sexp-backward" "s x b" #'sp-backward-sexp
        :desc "sexp-kill" "s x d" #'sp-kill-sexp
        :desc "sexp-kill" "s x s" #'+default/search-other-project)))


#+end_src

#+RESULTS:
: +default/search-other-project


* dashboard
I'm just make the dashboard display agenda and links to the files that I'm recently editing.
#+begin_src emacs-lisp
(use-package dashboard
  :config
  (dashboard-setup-startup-hook))
(setq dashboard-theme-directory (assoc-delete-all 'recents dashboard-item-generators))

(custom-set-faces!
  '(doom-dashboard-banner :foreground "red"  :weight bold)
  '(doom-dashboard-footer :inherit font-lock-constant-face)
  '(doom-dashboard-footer-icon :inherit all-the-icons-red)
  '(doom-dashboard-menu-desc :inherit font-lock-string-face)
  '(doom-dashboard-menu-title :inherit font-lock-function-name-face))
(set-face-attribute 'default nil :height 120)
#+end_src

#+RESULTS:

* Langs and Dev
This is so boring now. Just declaration for the lsp.
** glsl-mode
#+begin_src emacs-lisp
(use-package! glsl-mode)
(add-to-list 'auto-mode-alist '("\\.gdshader\\'" . glsl-mode))
#+end_src
** mermaid
#+begin_src emacs-lisp
(setq ob-mermaid-cli-path "/usr/bin/mmdc")

#+end_src

** plantuml
#+begin_src emacs-lisp
(setq org-plantuml-jar-path "~/.emacs.d/lib/plantuml.jar")
#+end_src
** LSP
*** auto
#+begin_src emacs-lisp
(setq lsp-auto-guess-root t)
(global-ede-mode t)
#+end_src

#+RESULTS:
: t

*** gdscript-mode
#+begin_src emacs-lisp
(when (string-equal system-type "darwin")
(setq gdscript-godot-executable "~/Desktop/Godot.app/Contents/MacOS/Godot"))

(setq gdscript-godot-executable "~/Downloads/Godot_v3.5-stable_x11.64")

 (defun lsp--gdscript-ignore-errors (original-function &rest args)
  "Ignore the error message resulting from Godot not replying to the `JSONRPC' request."
  (if (string-equal major-mode "gdscript-mode")
      (let ((json-data (nth 0 args)))
        (if (and (string= (gethash "jsonrpc" json-data "") "2.0")
                 (not (gethash "id" json-data nil))
                 (not (gethash "method" json-data nil)))
            nil ; (message "Method not found")
          (apply original-function args)))
    (apply original-function args)))
;; Runs the function `lsp--gdscript-ignore-errors` around `lsp--get-message-type` to suppress unknown notification errors.
(advice-add #'lsp--get-message-type :around #'lsp--gdscript-ignore-errors)
#+end_src

*** typescript
#+begin_src emacs-lisp :results silent
(add-hook 'typescript-mode-hook 'lsp-deferred)
(load-file "~/addhook/ob-typescript/ob-typescript.el")
#+end_src

#+RESULTS:


*** dap

#+begin_src emacs-lisp
(use-package dap-mode
  :custom
  (dap-lldb-debug-program `("/Users/motchang/.vscode/extensions/lanza.lldb-vscode-0.2.2/bin/darwin/bin/lldb-vscode"))
  :config
  (dap-mode 1)
  (dap-tooltip-mode 1)
  (require 'dap-lldb)
  (use-package dap-ui
      :ensure nil
      :config
      (dap-ui-mode 1)))
  (require 'dap-node)
(defun my-setup-dap-node ()
  "Require dap-node feature and run dap-node-setup if VSCode module isn't already installed"
  (unless (file-exists-p dap-node-debug-path) (dap-node-setup)))
(add-hook 'typescript-mode-hook 'my-setup-dap-node)
#+end_src

** shell
Just reading the enviroment valuable in .bashrc, bash_profile.
#+begin_src emacs-lisp
  (exec-path-from-shell-initialize)
#+end_src
** key-bind
Maybe I should use dumb-jump, But it's okay, it's working...
#+begin_src emacs-lisp
(defun mark-and-find-definition ()
  (interactive)
  (evil-set-marker ?c)
  (lsp-find-definition))

(map! (:leader
      (:desc "lsp search difinition" "l s d" #'mark-and-find-definition)))
#+end_src


* LISP
setup for multiple lisp.
** SCHEME
Just gauche.
#+begin_src emacs-lisp
(setq geiser-gauche-binary "/usr/bin/gosh")
(setq scheme-program-name "gosh -i")
(setq geiser-active-implementations '(guile gauche))
(use-package geiser-gauche
  :after geiser
  :init (add-to-list 'geiser-active-implementations 'gauche))
#+end_src

#+RESULTS:
: geiser-gauche

** RACKET
#+begin_src emacs-lisp
(add-hook 'racket-mode-hook
          (lambda ()
            (define-key racket-mode-map (kbd "<f5>") 'racket-run)))
(setq racket-program "/Applications/Racket\sv8.5/bin/racket")
#+end_src
** CLISP
**** SLY
#+BEGIN_SRC emacs-lisp
(use-package sly)
#+END_SRC


*** COCONUT
#+begin_src emacs-lisp
(use-package! coconut-mode)
(add-to-list 'auto-mode-alist '("\\.coco\\'" . coconut-mode))
#+end_src
*** elisp
#+begin_src emacs-lisp
(use-package! request)
#+end_src

* Org
** general
#+begin_src emacs-lisp
(defun head-add ()
  (interactive)
  (with-current-buffer
      (let ((content (read-string "* ")))
        (insert (concat "* " content "\n")))))

(map! :leader
      :desc "don't wanna write * again and again" "h h" #'head-add)

;;Just inserting link not completing the link section whole. Cuase I don't know how to access the clipboard from emacs.
(defun link-easer ()
  (interactive)
  (insert
   (format "[[][%s]]" (read-string "what is the title >")))
  (with-current-buffer (current-buffer)
    (re-search-backward "\\[\\]")
    )
  )

(map! :leader
      :desc "inserting link"
      "l n"#'link-easer)

#+end_src

#+RESULTS:
: link-easer

** habit
#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

** Directory
#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "darwin")
(setq org-directory "~/org"))
(when (string-equal system-type "gnu/linux")
(setq org-directory "~/org")
)

#+END_SRC
** Journal
#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "gnu/linux")
  (setq org-journal-dir "~/Dropbox/roam/journal" )
  )


(setq org-journal-date-format "%A, %d %B %Y")
(require 'org-journal)

#+end_src
** Agenda

#+begin_src emacs-lisp

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator #x2501
      org-agenda-compact-blocks t
      org-agenda-start-with-log-mode t)
(with-eval-after-load 'org-journal
(when (string-equal system-type "darwin")

  (setq org-agenda-files '("~/org/todo.org"
                           "~/org/elisptodo.org"
                           )))

)
(when (string-equal system-type "gnu/linux")

  (setq org-agenda-files '("~/org")))

(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))
(setq org-agenda-deadline-faces
      '((1.0001 . org-warning)              ; due yesterday or before
        (0.0    . org-upcoming-deadline)))  ; due today or later

#+end_src



**** agenda styles
#+begin_src emacs-lisp
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(setq org-agenda-custom-commands
      '(("n" "basic"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (agenda "" ((org-agenda-span 4)))
          (alltodo ""
                   ((org-agenda-skip-function
                     '(or (air-org-skip-subtree-if-priority ?A)
                          (org-agenda-skip-if nil '(scheduled deadline))))))))
        ("w" "habits"
         ((alltodo ""
                   (org-habit-show-habits t))))))

                     #+end_src
** Pomodoro
#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
    :after org-agenda
    :custom
    (org-pomodoro-ask-upon-killing t)
    (org-pomodoro-format "%s")
    (org-pomodoro-short-break-format "%s")
    (org-pomodoro-long-break-format  "%s")
    :custom-face
    (org-pomodoro-mode-line ((t (:foreground "#ff5555"))))
    (org-pomodoro-mode-line-break   ((t (:foreground "#50fa7b"))))
    :hook
    (org-pomodoro-started . (lambda () (notifications-notify
                                               :title "org-pomodoro"
                           :body "Let's focus for 25 minutes!"
                           :app-icon "~/.emacs.d/img/001-food-and-restaurant.png")))
    (org-pomodoro-finished . (lambda () (notifications-notify
                                               :title "org-pomodoro"
                           :body "Well done! Take a break."
                           :app-icon "~/.emacs.d/img/004-beer.png")))
    :config
    :bind (:map org-agenda-mode-map
                ("p" . org-pomodoro)))

#+END_SRC


*** Startup settings
#+begin_src emacs-lisp
;;(setq org-startup-folded t)
#+end_src
*** Babel
**** Template
#+BEGIN_SRC emacs-lisp :results silent
(defun efs/org-babel-tangle-config ()
  (when (string-equal (file-name-directory (buffer-file-name))
                      (expand-file-name "home/ryu/.doom.d/config.org"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))

(org-babel-do-load-languages
 'org-babel-load-languages
 '(lisp . t)
 '(awk . t)
 '(bash . t)
 '(mermaid . t)
 '(python . t)
 '(haskell. t)
 '(C++ . t)
 '(dot . t)
 '(js . t)
 '(typescript . t)
 '(ditaa . t)
 '(plantuml. t)
 '(lilypond. t)
 '(rust . t)
 '(gnuplot . t)
 )
#+end_src

**** TODO typescript
https://github.com/lurdan/ob-typescript
の DEMO がうまく動作せず、
https://www.reddit.com/r/emacs/comments/b7rsxu/behold_orgbabelexecutetypescript/
で、トランスパイルを/tmp/でやろうとしている人がいて、うごいてなかった（ふつうに =npx tsc= が失敗している）のをみて、とりあえず、実行ごとに typescript をいれるだけしている（めちゃくちゃおそい）

#+begin_src emacs-lisp

(defun org-babel-execute:typescript (body params)
  (org-babel-execute:js
   (with-temp-buffer
     (let* ((ts-file (concat (temporary-file-directory) (make-temp-name "script") ".ts"))
            (js-file (replace-regexp-in-string ".ts$" ".js" ts-file)))
       (insert body)
       (write-region nil nil ts-file)
       (call-process-shell-command (concat "npx tsc " (shell-quote-argument ts-file)))
       (delete-region (point-min) (point-max))
       (insert-file js-file)
       (let ((js-source (buffer-substring (point-min) (point-max))))
         (delete-file ts-file)
         (delete-file js-file)
         js-source)))
   params))

(defalias 'org-babel-execute:ts 'org-babel-execute:typescript)
#+end_src

#+RESULTS:

**** circler
Circle is tiny little software which reads the code progression written in plain text.
The field separator is pipe ~|~; the result is the view of the openGL.
#+begin_src emacs-lisp
(setq org-babel-circler-excutebale "~/edu/clang/painting/unko")

(defun org-babel-execute:circler (body _)
  (interactive)
  "Org mode circler evaluate function"
  (let* ((filename "teston.txt")
         (cmd (concat org-babel-circler-excutebale " ./" filename)))
    (unless (shell-command-to-string (concat "cat" filename))
      (make-empty-file filename))
    (with-temp-file filename
      (insert body))
      (org-babel-eval cmd body)))
#+end_src


** org-roam
Org roam is package for personal(or you can make something with you friends), knowledge pages(wiki).
I just put the template for each wiki below. And my homepage is using snippet here, just taking advantage of the commands of the package to obtain the information of the graph of my articles.
*** org-roam-capture-template
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-capture-templates
        '(("d" "default" plain
           "%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)

          ("l" "programming language" plain
           "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference:\n\n"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)

          ("b" "book notes" plain
           "\n* Source\n\nAuthor: %^{Author}\nTitle: ${title}\nYear: %^{Year}\n\n* Summary\n\n%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
          ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          ("s" "ordinary stuff" "* aha"
           :fi-new (file+haed "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          )))

(defun get-roam-links-json ()
  (json-encode-alist
   (org-uniquify-alist
    (mapcar #'(lambda (x) (list (intern (car x)) (cadr x)))
            (org-roam-db-query
             `[:select  [links:source
                         links:dest]
               :from links
               :where (= links:type "id")])))
   ))

(defun get-roam-nodes-json ()
  (json-encode-alist (org-roam-db-query [:select [id
                                                  file
                                                  title
                                                  level
                                                  pos
                                                  olp
                                                  properties
                                                  (funcall group-concat tag
                                                           (emacsql-escape-raw \, ))]
                                         :as tags
                                         :from nodes
                                         :left-join tags
                                         :on (= id node_id)
                                         :group :by id])))


;; for the homepage, I have to prepare the id and link information as json.
(defun create-node-and-link-json ()
  (interactive)
  (let ((output-dir "~/Dropbox/POKE/Web/raedme/public/texts"))
    (when (equal org-roam-directory output-dir)
      (with-temp-file  (concat output-dir "/links.json")
        (insert (get-roam-links-json)))
      (with-temp-file (concat output-dir "/nodes.json")
        (insert (get-roam-nodes-json)))
      )
    (message "node.json and links.json was written")
    ))

(add-to-list 'org-roam-capture-new-node-hook #'create-node-and-link-json)

#+end_src

*** dir-option
#+begin_src emacs-lisp
(defun select-roam-db ()
  (interactive)
  ;;personal use
  (let ((select '((me . roam)
                  ;; with my friend
                  (share . loggg)
                  ;; Obviously, for the homepage.
                  (homepage . homepagr/raedme/public/texts))))

    (ivy-read "🐕🐕どのwikiにするか🐕🐕" select
              :require-match t
              :action (lambda (choice)
                        (setq org-roam-directory (concat "~/Dropbox/"
                                                         (symbol-name (cdr choice)))))))
  (org-roam-db-sync))
#+end_src

#+RESULTS:
: select-roam-db


*** org-roam-ui
Just for org-roam-ui, completely same as the readme of the org-roam-ui. Just boring.
#+begin_src emacs-lisp
(setq org-roam-directory "~/Dropbox/roam")
(use-package org-roam-bibtex
  :after org-roam
  :config
  (require 'org-ref))

(use-package! websocket
    :after org-roam)
    <sh

(use-package! org-roam-ui
    :after org ;; or :after org
         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
         a hookable mode anymore, you're advised to pick something yourself
**** if you don't care about startup time, use
    :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
         org-roam-ui-follow t
          org-roam-ui-update-on-save t
         org-roam-ui-open-on-start t))


#+END_SRC
*** org-roam-dialies
Templates for my dailies.
#+begin_src emacs-lisp
(setq org-roam-dailies-directory "~/Dropbox/roam/journal")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (setq org-roam-dialies-capture-template                                    ;;
;;       '(("d" "default" entry "* %<%I:%H%p>: %?"                            ;;
;;         :if-new (file+head "%S<%Y-%m-%d>.org" "#+title: %<%Y-%m%d>\n?")))) ;;
;;;;;;;;;;;f;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


#+end_src
**** (setq org-roam-dailies-capture-templates
      '(("d" "Journal" entry "* %<%H: %M>\n"
         :if-new (file+head+olp "%<%Y-%m-%d>.org"
  	  	        "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
		  	        ("Journal")))
        ("b" "books" entry "* books"
         :if-new (file+head+olp "%<%Y-%m-%d>.org"
  	  	        "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
		  	        ("Journal")))


        ("m" "Most Important Thing" entry "* TODO %? :mit:"
         :if-new (file+head+olp "%<%Y-%m-%d>.org"
			        "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
			        ("Most Important Thing(s)")))))


#+end_src
** elgantt
#+begin_src emacs-lisp
(use-package! elgantt)

(setq elgantt-user-set-color-priority-counter 0)
(elgantt-create-display-rule draw-scheduled-to-deadline
  :parser ((elgantt-color . ((when-let ((colors (org-entry-get (point) "ELGANTT-COLOR")))
                               (s-split " " colors)))))
  :args (elgantt-scheduled elgantt-color elgantt-org-id)
  :body ((when elgantt-scheduled
           (let ((point1 (point))
                 (point2 (save-excursion
                           (elgantt--goto-date elgantt-scheduled)
                           (point)))
                 (color1 (or (car elgantt-color)
                             "black"))
                 (color2 (or (cadr elgantt-color)
                             "red")))
             (when (/= point1 point2)
               (elgantt--draw-gradient
                color1
                color2
                (if (< point1 point2) point1 point2) ;; Since cells are not necessarily linked in
                (if (< point1 point2) point2 point1) ;; chronological order, make sure they are sorted
                nil
                `(priority ,(setq elgantt-user-set-color-priority-counter
                                  (1- elgantt-user-set-color-priority-counter))
                           ;; Decrease the priority so that earlier entries take
                           ;; precedence over later ones (note: it doesn’t matter if the number is negative)
                           :elgantt-user-overlay ,elgantt-org-id)))))))

(setq elgantt-header-type 'outline
      elgantt-insert-blank-line-between-top-level-header t
      elgantt-startup-folded nil
      elgantt-show-header-depth t
      elgantt-draw-overarching-headers t)
#+end_src

** reading
Commands for code reading. I borrow the sneppet from ladicle's one.
#+begin_src emacs-lisp
(defconst ladicle/org-journal-dir "~/roam/journal/")
(defconst ladicle/org-journal-file-format (concat ladicle/org-journal-dir "%Y%m%d.org"))

(defvar org-code-capture--store-file "")
(defvar org-code-capture--store-header "")

;; This function is used in combination with a coding template of org-capture.
(defun org-code-capture--store-here ()
  "Register current subtree as a capture point."
  (interactive)
  (message "the header is stored")
  (setq org-code-capture--store-file (buffer-file-name))
  (setq org-code-capture--store-header (nth 4 (org-heading-components))))

;; This function is used with a capture-template for (function) type.
;; Look for headline that registered at `org-code-capture--store-header`.
;; If the matching subtree is not found, create a new Capture tree.
(defun org-code-capture--find-store-point ()
  "Find registered capture point and move the cursor to it."
  (let ((filename (if (string= "" org-code-capture--store-file)
                      (format-time-string ladicle/org-journal-file-format)
                    org-code-capture--store-file)))
    (set-buffer (org-capture-target-buffer filename)))
  (goto-char (point-min))
  (unless (derived-mode-p 'org-mode)
    (error
     "Target buffer \"%s\" for org-code-capture--find-store-file should be in Org mode"
     (current-buffer))
    (current-buffer))
  (if (re-search-forward org-code-capture--store-header nil t)
      (goto-char (point-at-bol))
    (goto-char (point-max))
    (or (bolp) (insert "\n"))
    (insert "* Capture\n")
    (beginning-of-line 0))
  (org-end-of-subtree))

;; Capture templates for code-reading
(add-to-list 'org-capture-templates
      '("u" "code-link"
         plain
         (function org-code-capture--find-store-point)
         "% {Summary}\n%(with-current-buffer (org-capture-get :original-buffer) (browse-at-remote--get-remote-url))\n# %a"
         :immediate-finish t))

(add-to-list 'org-capture-templates
        '("p" "just-code-link"
         plain
         (function org-code-capture--find-store-point)
         "%A"
         :immediate-finish t))

;;keybinding
(map! (:leader
      (:desc "counsel capture" "c p" #'counsel-org-capture
       :desc "counsel capture"
      "y c" #'org-code-capture--store-here)))

#+end_src


** babel
For org-babel, I just wanna make it look surrounded on the left side. The overlay of the ~org-modern~ is not my taste, so I've disabled the functionality partially.
#+begin_src emacs-lisp
(use-package org-modern-indent
  ;; :straight or :load-path here, to taste
  :hook
  (org-indent-mode . org-modern-indent-mode))
(add-hook 'org-mode-hook #'org-modern-mode)

(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
(setq org-modern-table nil)
(progn
  (add-to-list 'load-path "~/.emacs.d/site-lisp")
  (require 'org-pretty-table)
  (add-hook 'org-mode-hook (lambda () (org-pretty-table-mode))))
(map! :leader
      :desc "execute under the subtree"
      "d o" #'org-babel-execute-subtree)
#+end_src

** org-benrify
*** To search each headlines
When editting ~.org~ file, I often search that using pattern matching like with this ~*~, then move back and forth. But I've make the list of the headline in the floating window using ~ivy~.
Go to the headiline point as the top of the screen.
#+begin_src emacs-lisp
(defun display-list-of (what-to-find)
  (interactive)
  (defun get-existing-heading-in-buffer ()
    (save-excursion
      (goto-char (point-min))
      (let ((head '()))
        (while (re-search-forward what-to-find (point-max) t)
          (add-to-list 'head (list (replace-regexp-in-string "\n" "" (thing-at-point 'line nil) )(point)))
          )
        head)))
  (ivy-read "headings> " (reverse (get-existing-heading-in-buffer))
            :action (lambda (x) (progn (goto-char (cadr x)) (evil-scroll-line-to-top (line-number-at-pos))))))
(map! :leader
      :desc "heading list of current buffer"
      "l h" (lambda () (interactive) (display-list-of "^*")))

(map! :leader
      :desc  "display TODO in the buffer and go there if you want"
      "l t" (lambda () (interactive) (display-list-of "TODO")))
#+end_src



#+RESULTS:
| lambda | nil | (interactive) | (display-list-of TODO) |


** tempo
shortcut for babel, using tab key to complete to the cons things below.
Just shoutcut keywords for src-block. I really want to add the =:results output= as the default.

#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("ru" . "src rust"))
(add-to-list 'org-structure-template-alist '("cc" . "src C"))
(add-to-list 'org-structure-template-alist '("cl" . "src lisp"))
(add-to-list 'org-structure-template-alist '("aw" . "src awk"))
(add-to-list 'org-structure-template-alist '("ba" . "src bash"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("hs" . "src haskell"))
(add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
(add-to-list 'org-structure-template-alist '("pl" . "src plantuml"))
(add-to-list 'org-structure-template-alist '("js" . "src js"))
(add-to-list 'org-structure-template-alist '("circler" . "src circler"))
(add-to-list 'org-structure-template-alist '("lil" . "src lilypond"))
#+end_src

#+RESULTS:
: ((ts . src typescript) (hs . src ts) (lil . src lilypond) (circler . src circler) (js . src js) (pl . src plantuml) (hs . src haskell) (py . src python) (ba . src bash) (aw . src awk) (cl . src lisp) (cc . src C) (ru . src rust) (el . src emacs-lisp) (a . export ascii) (c . center) (C . comment) (e . example) (E . export) (h . export html) (l . export latex) (q . quote) (s . src) (v . verse))

** capture
#+begin_src emacs-lisp
(add-to-list 'org-capture-templates
        '("s" "ordinary stuff"
         plain
         #'(lambda () (print "para ppa"))
         "%a"
         :immediate-finish t))
#+end_src
* PREFERENCE
#+begin_src emacs-lisp
(defun my-pretty-lambda ()
  (setq prettify-symbols-alist '(("lambda" . 955))))
(add-hook 'python-mode-hook 'my-pretty-lambda)
(add-hook 'python-mode-hook 'prettify-symbols-mode)
(add-hook 'org-mode-hook 'my-pretty-lambda)
(add-hook 'org-mode-hook 'prettify-symbols-mode)
(add-hook 'lisp-mode-hook 'my-pretty-lambda)
(add-hook 'lisp-mode-hook 'prettify-symbols-mode)
(add-hook 'emacs-lisp-mode-hook 'my-pretty-lambda)
(add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)
#+end_src

* screen
#+begin_src emacs-lisp
(defun split-screen-1 ()
  (interactive)
  (progn
  (evil-window-split)
  (next-window-any-frame)
  (shrink-window 15)
  (evil-window-vsplit)
  (eshell)
  (next-window-any-frame)
  (org-agenda :key "n")
  (next-window-any-frame)
    ))

(defun split-screen-2 ()
  (interactive)
  (progn
  (evil-window-vsplit)
  (evil-window-split)
  (shrink-window 15)
  (evil-window-vsplit)
  (eshell)
  (next-window-any-frame)
  (org-agenda :key "n")
  (next-window-any-frame)
    ))

(defun split-screen-3 ()
  (interactive)
  (progn
  (evil-window-vsplit)
  (find-file "~/edu/clisp")
  (next-window-any-frame)
  (sly)
  (evil-window-vsplit)
  (org-roam-ref-find "clisp")
  ))

(defun split-screen-4 ()
  (interactive)
  (progn
    (let ((contest-num (read-string "What is the number of contest? :"))
          (dir-name nil))
  (evil-window-vsplit)
  (setq dir-name (concat "~/edu/python/abc" contest-num))
  (mkdir dir-name)
  (find-file (concat dir-name "/a.py"))
  (next-window-any-frame)
  (eshell)
  (next-window-any-frame)


    )))

  (use-package ace-window
   :custom-face
    (aw-leading-char-face ((t (:height 4.0 :foreground "#f1fa8c")))))
#+end_src
* tools
** vocacb
#+begin_src emacs-lisp
(defun append-string-to-file (s filename)
  (with-temp-buffer
    (insert s)
    (insert "\n")
    (write-region (point-min) (point-max) filename t)))

(defun ankki ()
  (interactive)
  (progn
    (let ((word (read-string "🐕Type in the word you don't know🐕: ")))
      (append-string-to-file word "~/Documents/words.txt")
      )
    (async-shell-command "python3 ~/.doom.d/asdf.py")
    )
  )


#+end_src
** TODO 矢印
キーマップはとりま設計書
- ├ からの分岐を考える
  下に伸ばしたいのがほとんどのはず？？
  作成した時点で上に追加しておく？
- 折り曲げた時に釣り合いが取れるかどうか。
  現在ある矢印のつながりを探索して、オブジェクト（クラスでも、構造体でもいいから）
  を作成して、そこから、おる。

*** keymap

|-----------+-----------+-------------------------+---------|
|           | key       | func name               | shape   |
|-----------+-----------+-------------------------+---------|
| create    | SPC a j k | arrow down right        | └─>     |
|           |           |                         |         |
|           | SPC a p h | arrow path horizontally | ┘ or └  |
|-----------+-----------+-------------------------+---------|
#+begin_src emacs-lisp

(defun yajirushi-add ()
  (interactive)
  (let ((length (cl-parse-integer(read-string "put the arrow length here: " "3") :radix 10))
        (result ""))
    (cl-do ((num 1 (1+ num)))
        ((> num length))
      (if (equal num length)
          (setq result (concat result "└─>"))
        (setq result (concat result "├─>\n"))))
    (with-current-buffer
        (insert result)
      (number-to-string (line-number-at-pos)))
    ))
;;横に伸びるやつ
(defun yajirushi-new-line ()
  (interactive)
  (cl-case (char-after)
    ((?│)
     (forward-line -1)
     (let ((line-content (thing-at-point 'line t)))
       (insert line-content)))
    ((?├)

     (forward-line 1)
     (let ((line-content (thing-at-point 'line t)))
       (insert "\n")
       (forward-line -1)
       (insert "│")
       ))

    ((?┬)
     (let ((line-content (thing-at-point 'line t))
           (end (point)))
       (beginning-of-line)
       (let* ((start (point))
              (offset (- end start)))
         (forward-line 1)
         (insert line-content)
         (forward-line -1)
         (cl-do ((num 0 (1+ num)))
             ((> num offset))
           (cl-case (char-after)
             ((?├)
              (delete-forward-char 1)
              (insert "│")
              (forward-char -1)
              )
             ((?┬)
              (delete-forward-char 1)
              (insert "└")
              (forward-char -1)
              )
             ((?─)
              (delete-forward-char 1)
              (insert " ")
              (forward-char -1)
              )
             ((?└)
              (delete-forward-char 1)
              (insert " ")
              (forward-char -1)
              )
             )

           (forward-char 1)
           )
         )))))
;;現在位置のXを保持したまま上へいく。
(defun yajirushi-go-upward ()
  (let ((end (point)))
    (beginning-of-line)
    (let* ((start (point))
           (offset (- end start))
           )
      (forward-line -1)
      (goto-char (+ offset (point)))
      )
    ))
;;もしかしたら、ぶつかるところがふえるかもしれない
(defun yajirushi-go-left ()
  (interactive)
  (while (not (equal (thing-at-point 'char t) "└"))
    (forward-char -1)))

(defun yajirushi-go-right ()
  (interactive)
  (while (not (equal (thing-at-point 'char t) "┘"))
    (forward-char 1)))
;;左までいって、上(yajirushi-go-upward)まで探索したら、そのポイントを保存する
;;右までいったら、そのポイントを保存する。
;;一つの辺に複数のHubがあったら、エラーを出す。
(defun detect-box ()
  (interactive)
  (let ((start) (top-left) (bottom-right))
    (setq start (point))
  (cl-case (char-after)
    ((?┯)
     (yajirushi-go-left)
     (while (not (equal (thing-at-point 'char t) "┌"))
       (yajirushi-go-upward))
     (setq top-left (point))
     (goto-char start)
     (yajirushi-go-right)
     (setq bottom-right (point))
     ))
  (print top-left)
  (print bottom-right)
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (defun adjust-box-shape () ;;
;;   (interactive))           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;文字の長さを調べるー＞その分上のやつを作る。
;;入力した文字の両端に縦の罫線をつける
(defun moji-tree ()
  (interactive)
  (let ((word (cl-parse-integer(read-string "put string here: " ))
        (result ""))
        (with-current-buffer
        (insert result)
      (number-to-string (line-number-at-pos)))
    )
                        ))

(defun yajirushi-rotate ()
  (interactive)
  (cl-case (char-after)
    ;;
    ((?└)
     (delete-forward-char 1)
     (insert "├"))
    ((?├)
     (delete-forward-char 1)
     (insert "┌"))
    ((?┌)
     (delete-forward-char 1)
     (insert "└"))
    ;;横から
    ((?─)
     (delete-forward-char 1)
     (insert "┬")
     (forward-char -1)
     )
    ((?┬)
     (delete-forward-char 1)
     (insert "─"))
    ))

(defun yajirushi-expand ()
  (interactive)
  (cl-case (char-after)
    ((?─)
     (insert "─"))))

;;TODO;;;;;;;;;;;;;;;;;;;;;;;;;
;; (defun box-display ()     ;;
;;   (interactive)           ;;
;;)                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;key-bind
(map! (:leader
      (:desc "個数を指定して矢印をつくる" "a j l" #'yajirushi-add
      :desc "文字の種類に応じて回転" "a r" #'yajirushi-rotate
      :desc "文字の種類に応じてのばす" "a x" #'yajirushi-expand
      :desc "文字の種類に応じて改行" "a o" #'yajirushi-new-line)))
#+end_src
* ivy
#+begin_src emacs-lisp
(use-package ivy-posframe
      :config
    (ivy-posframe-mode 1))
(setq ivy-posframe-parameters
      '((left-fringe . 10)
        (right-fringe . 10)))
#+end_src
* beacon
#+begin_src emacs-lisp
(use-package beacon
  :custom
     (beacon-color "white")
    :config
    (beacon-mode 1)
    )
#+end_src
* easy-draw
#+begin_src emacs-lisp
(with-eval-after-load 'org
  (require 'edraw-org)
  (edraw-org-setup-default))
#+end_src
* workspace
#+begin_src emacs-lisp
(defun open-this-buffer-in-workspece ()
  (interactive)
  (let ((where-i-was (current-buffer)))
    (+workspace/new)
    (switch-to-buffer where-i-was)))

(map! (:leader
       (:desc "to-workspace" "w z"#'open-this-buffer-in-workspece
        :desc "to-workspace" "w d"#'+workspace/delete)))
#+end_src


* journal utils
#+begin_src emacs-lisp
(defun extract-link-name (link-content)
  (let ((brace link-content))
    (string-match "\\]\\[\\(.*\\)\\]\\]" brace)
    (match-string 1 brace)))

(defun get-exsting-link-name ()
  (save-excursion
    (goto-char (point-min))
    (let ((rect-bracketed '()))
      (while (re-search-forward "^\\[" (point-max) t)
        (add-to-list 'rect-bracketed
                     (extract-link-name (thing-at-point 'line t))))
      rect-bracketed)))

(defun linkp (name)
  (if (member name (get-exsting-link-name))
      t
    nil))

;I couldn't find the prepared thing for the org-dailies
(defun get-today-file ()
  ;;get the file name of current date
  (let ((file-name (org-journal--get-entry-path))
        year month date)
    (string-match "[0-9]+" file-name)
    (setq file-name (match-string 0 file-name))
    (cl-destructuring-bind (year month date)
        (mapcar #'(lambda (pos) (substring file-name (cl-first pos) (car (last pos))))
                (list '(0 4) '(4 6) '(6 8)))
    (format "%s-%s-%s.org" year month date))))

(unless (file-exists-p (format "%s/%s" org-roam-dailies-directory (get-today-file)))
  (org-roam-dailies-capture-today :KEYS "d") (save-buffer))

(defun get-node-name (str)
  (string-match "-.*" str)
  (print (substring (match-string 0 str) 1 (length (match-string 0 str)))))

;this name should be on create journal
;most fishy place
(defun write-to (buffer)
  (with-current-buffer
      (let ((new-node (buffer-name)))
        (set-buffer buffer)
        (goto-char (point-max))

        (unless (file-exists-p (format "%s/%s" org-roam-dailies-directory (get-today-file)))
          (print "no-today file"))
        ; if the link exist, skip, if no, create the link to it.
        (unless (linkp (get-node-name new-node))
          (save-excursion
            (look-for-header-insert
             (format "[[%s][%s]]\n" (concat org-roam-directory "/" new-node) (get-node-name new-node)) "visited")
            ))
        (insert-header-unless-exist "visited")
        (print (current-buffer)))))

(defun add-url-to-journal ()
  (interactive)
  (look-for-header-insert (format "[[%s][%s]]\n" w3m-current-url(read-string "What's our title of this page?> ")) "visited"))

(add-hook 'org-roam-capture-new-node-hook (lambda () (write-to (get-today-file))))
(add-hook 'org-roam-find-file-hook (lambda () (write-to (get-today-file))))

(defun today-buffer ()
  (let ((dirname (org-journal--get-entry-path))
        journal-entry (ymd '((0 4) (4 6) (6 8))))
    (string-match "journal/\\(.*\\)$" dirname)
    (apply #'(lambda (y m d) (format "%s-%s-%s.org" y m d))
           (cl-map 'list
                   #'(lambda (each) (substring (match-string 1 dirname) (car each) (cadr each)))
                   ymd))))

(setq +org-capture-journal-file (concat "~/Dropbox/roam/journal/" (today-buffer)))

;TODO really don't wanna make it today-buffer specific.
(defun look-for-header-insert (content header)
  (set-buffer (today-buffer))
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward (concat "^\\* " header) (point-max) t)
      (insert (concat "\n" content)))))

(defun insert-header-unless-exist (head)
  (let ((headline (concat "* " head)))
    (unless (headerp (today-buffer) headline)
      (goto-char (point-max)) (insert headline))))

(defun headerp (buffer heading)
  (set-buffer buffer)
  (save-excursion
    (let ((nodes '()))
      (goto-char (point-min))
      (while (re-search-forward "^*" (point-max) t)
        (add-to-list 'nodes (replace-regexp-in-string "\n" "" (thing-at-point 'line t))))
      (if (member heading nodes)
          t
        nil)
      )))

;;setup the key-binds
(map! (:leader
       (:desc "dict-lookup-with-journal"
        "s t" (lambda ()
                (interactive)

                (let ((thing (doom-thing-at-point-or-region 'word)))
                  (insert-header-unless-exist "vocab")
                  (+lookup/dictionary-definition thing)
                  (look-for-header-insert thing "vocab")))
        )
       (:desc "leave history with the w3m"
        "c u r i" #'add-url-to-journal)))

(add-to-list 'org-capture-templates
             '("j" "Journal" entry
               (file +org-capture-journal-file)
               "* %?\n" :prepend t))
#+end_src
* おべんきょ
#+begin_src emacs-lisp
(defun shellgei ()
  (interactive)
  (let* ((-dir "~/shellgei160/")
         (qdata
          (-map (lambda (cand) (and (f-directory-p cand)
                                    (list cand (helm-list-directory cand))))
                (helm-list-directory (format "%sqdata" -dir))))
         (answer
          (-map (lambda (cand)
                  (format "%sanswer/%s.md" -dir (and (stringp (car cand))
                                                     (helm-basename (car cand)))))
                qdata)))
    (print answer)
    (ivy-read "mondai> "
              qdata
              :action (lambda (choice)
                        (progn
                          (setq current-question
                                (list
                                 choice (nth (cl-position choice qdata) answer)))
                          (dired (car choice)))))
    )
  )

(defun shellgei-back-and-forth ()
  (interactive)
  (if (string-match-p "qdata" (helm-current-directory))
      (dired (car (last current-question)))
    (find-file (caar current-question))
    ))

(map! :leader
      :desc "just navigation" "s g g" #'shellgei
      :desc "go to answer or question" "s g n" #'shellgei-back-and-forth
      )

#+end_src

** competitive
#+begin_src emacs-lisp
(use-package ob)
(setq atco-dir "~/competi/")
(defun atco ()
  (interactive)
  (let ((competi-buffer (get-buffer-create "*atcoder*"))
        (contest-name (read-string "Fill in contest name>> ")))
    (with-splited-window (shell "atcoder"))
    (comint-send-string (get-process "atcoder") (format "cd %s && acc new %s\n" atco-dir contest-name))
    ;;(comint-send-input (get-process "shell") "a")
    )
  )


(defun test-atco ()
  (interactive)
  (let ((exp (cadr (split-string (buffer-file-name (current-buffer)) "\\.")) )
        (file-with-fullpath buffer-file-name)
        (cwd (helm-basedir (buffer-file-name)))
        )

    (if
        (member "atcoder" (mapcar #'buffer-name (mapcar #'window-buffer (window-list))))
        (evil-window-right 1)
      (with-splited-window (shell "atcoder"))
      )

    (comint-send-string (get-process "atcoder")
                        (cond
                         ((equal exp "py")
                          (format "oj t -c \"python3 %s\" -d %s/tests/\n"  file-with-fullpath cwd))
                         ((equal exp "lisp") (format "oj t -c \"sbcl --script %s/main.lisp\" -d %stests/\n" (pwd) (pwd)))
                         ))))


(defun submit-atco()
  (interactive)
  (eshell "competi")
  (insert "acc s main.py")
  (execute-kbd-macro (kbd "<return>"))
  (execute-kbd-macro (kbd "<esc>")))

(general-simulate-key "SPC")
(map! (:leader
       (:desc "prepare tests and templates" "a t n" #'atco
        :desc "submit" "a t s" #'submit-atco
        :desc "test" "a t t" #'test-atco)))

#+end_src

#+RESULTS:
: test-atco

* cursor move
** "" の中身を消してくれるやつ
この辺はもうちょいうまくできそう
#+begin_src emacs-lisp
(defun go-and-delete-in-double-quote ()
  (interactive)
  (re-search-forward "\"" (line-end-position) t)
  (kill-region (mark) (1- (point)))
  )
(map! :leader
      :desc "delete-content-of-double-quote"
      "d l w" #'go-and-delete-in-double-quote)
#+end_src
** ) まで行ってくれるやつ
#+begin_src emacs-lisp
(defun goto-end-of-parenthesis ()
  (interactive)
  (set-mark (point))
  (re-search-forward ")" (line-end-position) t)
  (kill-region (mark) (1- (point))))
(map! :leader
      :desc "delete-content-of-double-quote"
      "d l )" #'goto-end-of-parenthesis)
#+end_src
* gif
For displaying the gif on the emacs.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'org-inline-anim-mode)
(defun inline-img-wrap ()
  (interactive)
  (org-inline-anim-animate 4))

(map! :leader
      :desc "added the prefix"
      "a n" #'inline-img-wrap)
#+end_src

* shell
#+begin_src emacs-lisp
;; load environment value
(dolist (path (reverse (split-string (getenv "PATH") ":")))
  (add-to-list 'exec-path path))
#+end_src

* browser
#+begin_src emacs-lisp
(use-package! w3m
  :commands (w3m)
  :config
  (setq w3m-use-tab-line nil))

(map! (:leader
       (:desc "just goes to w3m "
        "w 3"
        (lambda () (interactive)
          (with-splited-window (w3m))))))

(setq gdscript-docs-local-path "~/sites/godot/")
(setq org-roam-directory "~/Dropbox/roam")

(defun shell-command-existp (command)
  (cl-case (shell-command
            (format "command -v %s" command))
    (0 't)
    (1 'nil)
    ))

(defun read-book-with-chrome ()
  (interactive)
  (let* ((browser-candidate
          '("google-chrome-stable" "chromium"))

    (browser-to-use (car (cl-remove-if #'null (-map (lambda (c) (when (shell-command-existp c) c)) browser-candidate)))))

    (ivy-read "books to read> "
              (split-string (shell-command-to-string "cd ~/Dropbox/books && ls") "\n")
              :require-match t
              :action (lambda (choice) (shell-command (concat (format "%s ~/Dropbox/books/" browser-to-use) (format "\"%s\"" choice)))))))

(map! :leader
      :desc "using chrome, reading things, If the nyxt gets better I would use that."
      "b o" #'read-book-with-chrome)
#+end_src

#+RESULTS:
: read-book-with-chrome


* misc
uncategorized
#+begin_src emacs-lisp
;(use-package nyan-mode)
;(setq nyan-mode t)
;;(setq doom-modeline-mode 'nil)
(load-file "~/Dropbox/POKE/Elisp/pokel.el")
;;(setq pokel-mode t)
(load "~/Dropbox/POKE/Elisp/musica.el")
#+end_src

#+RESULTS:
: t

:PROPERTIES:
:ARCHIVE:  asdf
:END:


* git
Key binds for magit in doom way.
#+begin_src emacs-lisp
(map! (:leader
       :desc "git commit after stageing" "g c s"
       (lambda () (interactive) (magit-stage) (magit-commit))))
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (magit-stage) | (magit-commit) |

* window
utils for using window. I think this is a bit not categorized well
#+begin_src emacs-lisp
;;FIXME looks ugly. This just work. Can I use the _advice-add_ for this?
(defun find-file-other-window ()
  (interactive)
  (with-splited-window
   (find-file
    (car (find-file-read-args "Find file: "
                        (confirm-nonexistent-file-or-buffer)))
    )))

(map! (:leader
       :desc "split the window and search file" "f F" #'find-file-other-window))

(defun message-buffer-in-other-window()
  (interactive)
  (org-switch-to-buffer-other-window "*Messages*"))
(map! (:leader
       :desc "just jumping to the message buffer" "l o g" #'message-buffer-in-other-window))

(modus-themes-load-vivendi)
(defun get-max-linum (&optional file-or-buffer)
  (interactive)
  (cl-flet ((go-and-get-max-line ()(save-excursion
                                     (goto-char (point-max))
                                     (print (- (line-number-at-pos) 1))
                                     )))
    (cond
     ((null file-or-buffer)
      (go-and-get-max-line))
     ((eql (type-of file-or-buffer) 'buffer)
      (set-buffer file-or-buffer))
     ((eql (type-of file-or-buffer) 'file)
      (print "asdf"))
     ('t (message "%s is not either the type; file, buffer, nil"))
     )))
        #+end_src

        #+RESULTS:
        : get-max-linum


* lang
#+begin_src emacs-lisp
(set-language-environment "Japanese")
(map! :leader
      :desc "convert to katakana" "k n" #'japanese-katakana-region
      :desc "switch to japanese" "j a" #'(lambda () (interactive) (set-input-method "japanese"))
      :desc "switch to english" "e n" #'(lambda () (interactive) (set-input-method "ucs")))

(load "~/Projects/emacs/deepl.el")
(load "~/Projects/emacs/gpt.el")

(defun hira-kata (start end)
  (interactive "r")
  (let ((region (buffer-substring start end)))
    (delete-region start end)
    (insert (shell-command-to-string (concat "python ~/tools/hiragana_katakana.py " region)))))
#+end_src

#+RESULTS:
: hira-kata

* calender
#+begin_src emacs-lisp
(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")  ; org-agenda source
    (cfw:org-create-file-source "cal" "~/Dropbox/cal.org" "Cyan")  ; other org source
    )))

(map! :leader
      :desc "calender view" "s c h" #'my-open-calendar
      :desc "calender at point" "g c a l" #'org-gcal-post-at-point)

(let ((gcal-infos (json-read-file "~/Dropbox/au.json")))
  (setq
   org-gcal-client-id
   (cdr (assoc 'client_id (cdar gcal-infos)))
   org-gcal-client-secret (cdr (assoc 'client_secret (cdar gcal-infos)))
   ;; ID が sample@foo.google.com のカレンダーと ~/calendar.org を同期
   org-gcal-file-alist '(
                         ("the.brainga@gmail.com" . "~/calendar.org")
                         ("the.brainga@foo.google.com" .  "~/calendar2.org")
                         ))
  ;; token の保存場所を変更
  (setq org-gcal-dir "~/Dropbox/org-gcal")

  )
#+end_src


* nyxt
#+begin_src emacs-lisp
(map! :leader
      :desc "connect sly" "c n" (lambda () (interactive) (sly-connect "localhost" 4545)))

;;helper functions used by =emacsclient=.
#+end_src
| lambda | nil | (interactive) | (sly-connect localhost 4545) |

* autoload
#+begin_src emacs-lisp

;;;### (autoloads nil "tscn" "tscn.el" (25422 56915 349704 301000))
;;; Generated autoloads from tscn.el

(register-definition-prefixes "gdutil" '("format-prop" "group-by-prop" "prop-p" "tscn-lst"))

;kszxcvkj;;***

(register-definition-prefixes "test" '("testfile"))
#+end_src
